{"_path":"/page3","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"Mobile App Development with Flutter (Part 2)","description":"Second part of a multi-parted blog post about Dart language and Flutter framework. In this part, we'll plan how we are going to build an app.","excerpt":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"second-step-plan-and-practice"},"children":[{"type":"text","value":"Second Step: Plan and Practice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After learning how to play the game, in this case learning the Dart programming language and Flutter SDK, we need to decide what we will do with them. As I mentioned in the previous post, I want to create a Twitter clone with core Twitter functionality. Now let's think about it and decide how we are going to build it."}]},{"type":"element","tag":"h3","props":{"id":"the-plan"},"children":[{"type":"text","value":"The Plan"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the previous post, I mentioned a few words about Firebase. Firebase is equipped to provide everything that we are most likely to need in this project. With that in mind, let's start planning."}]},{"type":"element","tag":"h4","props":{"id":"authentication"},"children":[{"type":"text","value":"Authentication"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As a first step, we need to provide authentication, sign-in, and sign-up screens for our users. We provide this feature through Firebase Authentication. For the sign-in page, we need fields for users to enter their credentials, e-mail address, and password. Also a button to sign-in and a button to redirect users to the sign-up page if they don't have an account."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-in page","src":"/img/page3/sigin.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The sign-up page is expected to be more complicated than the sign-in. At sign-up I don't want to just register the user, but I also want to get information about the user, like the user's bio. For that we are preparing to build a 2-step sign up page. The first step is for credentials and 2 step is for profile information. For this reason, we are going to use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/Stepper-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"Stepper widget"}]},{"type":"text","value":" here. The stepper widget allows me to progress step by step. When the user is finished, we will register the user via Firebase Authentication and redirect to our main page, which is the timeline."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-up Step 1","src":"/img/page3/signup1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When we look at which information we ask from users, those are also the core information that Twitter wants from users. A brief biography (maximum 240 characters), a website link, location and full name. We will store these information in the Firebase Firestore database, in the users document. For every user that signed-up, Firebase Authentication provides that user a unique id. We will use this id as document name, and store data. In this way, we could create relationships easily."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-up Step 2","src":"/img/page3/signup2.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"timeline"},"children":[{"type":"text","value":"Timeline"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The timeline page is meant to be our homepage and host a lot of content that we build. We will fetch and show tweets from the user's followings. For this we will use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/widgets/ListView-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"Listview widget"}]},{"type":"text","value":". Its name suggests that the listview widget lists all the tweets that we fetch from Firestore. It has a builder method, that loads only the visible list items for performance."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Timeline","src":"/img/page3/timeline.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For realtime data fetching, will use "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"StreamBuilder widget"}]},{"type":"text","value":". This widget listens to incoming streams, in this context the provided websocket from Firestore, then rebuilds the children widgets."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We will retrieve a limited number of tweets when fetching tweets from Firestore with StreamBuilder widget to increase app performance and reduce redundant network traffic. I will load 20 tweets at a time, and load new tweets when the user scrolls to the bottom. Additionally, we will add "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/RefreshIndicator-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"RefreshIndicator widget"}]},{"type":"text","value":" to refresh the timeline by pulling down."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For displaying a tweet in the Listview, we also need to build our custom tweet widget. This widget shows the body of the tweet, the user who posted it and stats; like, retweet and quote count."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Other than these, we will build two "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/Drawer-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"App Drawers"}]},{"type":"text","value":", one for navigation and one for showing search field and trending hashtags."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, we will add a "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/FloatingActionButton-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"floating action button"}]},{"type":"text","value":" that redirects users to a tweet composition page."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For the database part of timeline, we will store all tweets in the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"tweets"}]},{"type":"text","value":" document in the Firestore. Each tweet document has several fields which are: body, createdAt, likes, originalTweet, replies, retweets, type, user and userId."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The body field will hold the tweet text that the user entered. The created at field stores the time the tweet was posted. Users who liked the tweet are also stored in the \"likes\" field. Original tweet field is here for replies and retweets. When a user retweets a tweet we will define the tweet type to retweet and display the original tweet in the body of the retweet. We're planning to use the user ID for filtering the tweets by followings. The user field is here to fetch the user's details. Right now, I will not accept any media from users, but Firebase Storage will allow us to do so."}]},{"type":"element","tag":"h4","props":{"id":"profile"},"children":[{"type":"text","value":"Profile"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another significant screen that we will build is the profile page. The timeline and this page share the same app bar design. In addition to that, we will show the user's cover art and profile picture at the top. For now, we will use some placeholders for both. Also the banner will display the user's biography, tweet, following and follower counts. In addition, we want to display a follow/unfollow button for each user profile other than the user's own profile."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Profile","src":"/img/page3/profile.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Moreover we will use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/BottomNavigationBar-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"BottomNavigationBar"}]},{"type":"text","value":" widget to show the user's tweets and replies on different pages. Just as we provide a RefreshIndicator widget to refresh the timeline, we will also provide a RefreshIndicator widget to refresh the profile page. With this feature, we can update tweet stats and new tweets."}]},{"type":"element","tag":"h4","props":{"id":"explore"},"children":[{"type":"text","value":"Explore"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Explore page will show the top 10 trending topics and their statistics. The Listview widget is also used for this purpose. When we look at how we will get hashtags from tweet, we will add "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"mentions"}]},{"type":"text","value":" and "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"hashtags"}]},{"type":"text","value":" fields to each tweet document. Then we will define a scheduled task in Firebase to look up tweets that were posted last hour. This task will generate list of top 10 hashtags that were use."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The trending topics will be listed like tweets in the timeline when the user chooses to view them. We will fetch 20 tweets at a time and display them in ascending order of their creation time."}]},{"type":"element","tag":"h4","props":{"id":"messages"},"children":[{"type":"text","value":"Messages"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The messages screen will host a basic real-time messaging application. We will host chats in the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"chats"}]},{"type":"text","value":" document in the Firestore and fetch chat and it's messages from there. For ease of implementation we won't let the user delete messages. Again for ease of implementation we only accept text messages."}]},{"type":"element","tag":"h4","props":{"id":"other-screens"},"children":[{"type":"text","value":"Other Screens"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We also have notifications and search results, in addition to all of these. With Firestore we could store all notifications, but I prefer to store the last 10 for ease of implementation. Firestore does not support full-text searching, so we have to rely on a third-party solution for our searches. In the official documentation, a few products are suggested for search. In light of this, I chose to stick with "},{"type":"element","tag":"a","props":{"href":"https://www.algolia.com/","rel":["nofollow"]},"children":[{"type":"text","value":"Algolia"}]},{"type":"text","value":" because it has Dart library and Firebase extension and it's free."}]},{"type":"element","tag":"h3","props":{"id":"practice"},"children":[{"type":"text","value":"Practice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With a broad plan in our hands, and an idea of how we will accomplish our goal, we need to solve an issue; how are we planning to communicate between our screens, in other words how are we planning to manage state? When it comes to state management, Flutter and Dart have lots of packages. The most known and used package is called "},{"type":"element","tag":"a","props":{"href":"https://pub.dev/packages/provider","rel":["nofollow"]},"children":[{"type":"text","value":"Provider"}]},{"type":"text","value":". In the first part, I mentioned a third type of widget called an "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"inherited widget"}]},{"type":"text","value":". Provider package wraps inherited widgets and provide us a useful API. So you might wonder, what is an inherited widget? An inherited widget does not have a display. Whenever you place an inherited widget into the widget tree, every child widget and every child of that child can reach directly to it. This is because there is no need for an intermediary widget. The provider package uses this feature to manipulate data. Any child can access this data and modify it easily. If you use a provider, you need to use the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"ChangeNotifier"}]},{"type":"text","value":" mixin to have the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"notifyListeners"}]},{"type":"text","value":" function. This function does the same job that "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"setState"}]},{"type":"text","value":" function does. It notifies Flutter that some data in the application state has changed, so it needs to rebuild the widgets."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While there are other options like Redux, BloC, and GetIt, I decided to stick with the "},{"type":"element","tag":"a","props":{"href":"https://riverpod.dev/","rel":["nofollow"]},"children":[{"type":"text","value":"RiverPod"}]},{"type":"text","value":" package because I find it easier to use. Also it uses similar API like provider package but it has far more features than that. Other than a basic provider, it has StateProvider for changing states, FutureProvider for asynchronous data and StreamProvider for realtime data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So how are we aiming to use state management in our application? In order to avoid re-fetching tweets, we have to store them in the cache when we retrieve them. Retrieving the data repeatedly wastes our time and delays the user. Apart from tweets, we need to store the user's information. This is because most of the time we need the user's data, for example when fetching tweets we need the user's followings. We don't want to fetch this information repeatedly. It will save the user a great deal of bandwidth and time in real-world applications."}]},{"type":"element","tag":"h4","props":{"id":"environment"},"children":[{"type":"text","value":"Environment"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I discuss a lot about Dart and Flutter, but do not mention anything about development environments. As a last thing, let's talk about it. For application development with Flutter, you need to have the SDK. The SDK can be downloaded from the "},{"type":"element","tag":"a","props":{"href":"https://docs.flutter.dev/get-started/install","rel":["nofollow"]},"children":[{"type":"text","value":"official website"}]},{"type":"text","value":". It supports most major operating systems. It also includes the Dart SDK, so you don't need to install both. After SDK installation, go to the command line or console and type "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"flutter doctor"}]},{"type":"text","value":". This command shows what dependencies are missing and what you should do. Other than that you must have Android SDKs, so I strongly suggest you to install Android Studio for that. Because you can select which SDKs to download and it has a built-in emulator with it. For programming you don't have to stick with Android Studio though, you can work with Visual Studio Code. All you need to install is the Flutter extension and you are ready to start."}]}]},"date":"2022-09-25T00:00:00.000Z","author":"Ümit Kara","slug":"mobile-app-development-with-flutter-part-2","image":{"src":"/blogImg/page3/flutter.webp","alt":"Mobile App Development with Flutter (Part 2)"},"head":{"meta":[{"name":"description","content":"Second part of a multi-parted blog post about Dart language and Flutter framework. In this part, we'll plan how we are going to build an app."},{"name":"keywords","content":"flutter, dart, mobile app development, umit kara, umitkara, ümit kara"},{"name":"author","content":"Ümit Kara"},{"name":"robots","content":"index, follow"},{"name":"og:url","content":"https://umitkara.github.io/blog/mobile-app-development-with-flutter-part-2"},{"name":"og:type","content":"website"},{"name":"og:title","content":"Mobile App Development with Flutter (Part 2)"},{"name":"og:description","content":"Second part of a multi-parted blog post about Dart language and Flutter framework. In this part, we'll plan how we are going to build an app."},{"name":"og:image","content":"https://umitkara.github.io/blogImg/page3/flutter.webp"},{"name":"twitter:card","content":"summary_large_image"},{"name":"twitter:title","content":"Mobile App Development with Flutter (Part 2)"},{"name":"twitter:description","content":"Second part of a multi-parted blog post about Dart language and Flutter framework. In this part, we'll plan how we are going to build an app."},{"name":"twitter:image","content":"https://umitkara.github.io/blogImg/page3/flutter.webp"}]},"body":{"type":"root","children":[{"type":"element","tag":"h2","props":{"id":"second-step-plan-and-practice"},"children":[{"type":"text","value":"Second Step: Plan and Practice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"After learning how to play the game, in this case learning the Dart programming language and Flutter SDK, we need to decide what we will do with them. As I mentioned in the previous post, I want to create a Twitter clone with core Twitter functionality. Now let's think about it and decide how we are going to build it."}]},{"type":"element","tag":"h3","props":{"id":"the-plan"},"children":[{"type":"text","value":"The Plan"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"In the previous post, I mentioned a few words about Firebase. Firebase is equipped to provide everything that we are most likely to need in this project. With that in mind, let's start planning."}]},{"type":"element","tag":"h4","props":{"id":"authentication"},"children":[{"type":"text","value":"Authentication"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"As a first step, we need to provide authentication, sign-in, and sign-up screens for our users. We provide this feature through Firebase Authentication. For the sign-in page, we need fields for users to enter their credentials, e-mail address, and password. Also a button to sign-in and a button to redirect users to the sign-up page if they don't have an account."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-in page","src":"/img/page3/sigin.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The sign-up page is expected to be more complicated than the sign-in. At sign-up I don't want to just register the user, but I also want to get information about the user, like the user's bio. For that we are preparing to build a 2-step sign up page. The first step is for credentials and 2 step is for profile information. For this reason, we are going to use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/Stepper-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"Stepper widget"}]},{"type":"text","value":" here. The stepper widget allows me to progress step by step. When the user is finished, we will register the user via Firebase Authentication and redirect to our main page, which is the timeline."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-up Step 1","src":"/img/page3/signup1.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When we look at which information we ask from users, those are also the core information that Twitter wants from users. A brief biography (maximum 240 characters), a website link, location and full name. We will store these information in the Firebase Firestore database, in the users document. For every user that signed-up, Firebase Authentication provides that user a unique id. We will use this id as document name, and store data. In this way, we could create relationships easily."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Sign-up Step 2","src":"/img/page3/signup2.png"},"children":[]}]},{"type":"element","tag":"h4","props":{"id":"timeline"},"children":[{"type":"text","value":"Timeline"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The timeline page is meant to be our homepage and host a lot of content that we build. We will fetch and show tweets from the user's followings. For this we will use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/widgets/ListView-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"Listview widget"}]},{"type":"text","value":". Its name suggests that the listview widget lists all the tweets that we fetch from Firestore. It has a builder method, that loads only the visible list items for performance."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Timeline","src":"/img/page3/timeline.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For realtime data fetching, will use "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"StreamBuilder widget"}]},{"type":"text","value":". This widget listens to incoming streams, in this context the provided websocket from Firestore, then rebuilds the children widgets."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We will retrieve a limited number of tweets when fetching tweets from Firestore with StreamBuilder widget to increase app performance and reduce redundant network traffic. I will load 20 tweets at a time, and load new tweets when the user scrolls to the bottom. Additionally, we will add "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/RefreshIndicator-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"RefreshIndicator widget"}]},{"type":"text","value":" to refresh the timeline by pulling down."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For displaying a tweet in the Listview, we also need to build our custom tweet widget. This widget shows the body of the tweet, the user who posted it and stats; like, retweet and quote count."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Other than these, we will build two "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/Drawer-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"App Drawers"}]},{"type":"text","value":", one for navigation and one for showing search field and trending hashtags."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Finally, we will add a "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/FloatingActionButton-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"floating action button"}]},{"type":"text","value":" that redirects users to a tweet composition page."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"For the database part of timeline, we will store all tweets in the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"tweets"}]},{"type":"text","value":" document in the Firestore. Each tweet document has several fields which are: body, createdAt, likes, originalTweet, replies, retweets, type, user and userId."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The body field will hold the tweet text that the user entered. The created at field stores the time the tweet was posted. Users who liked the tweet are also stored in the \"likes\" field. Original tweet field is here for replies and retweets. When a user retweets a tweet we will define the tweet type to retweet and display the original tweet in the body of the retweet. We're planning to use the user ID for filtering the tweets by followings. The user field is here to fetch the user's details. Right now, I will not accept any media from users, but Firebase Storage will allow us to do so."}]},{"type":"element","tag":"h4","props":{"id":"profile"},"children":[{"type":"text","value":"Profile"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Another significant screen that we will build is the profile page. The timeline and this page share the same app bar design. In addition to that, we will show the user's cover art and profile picture at the top. For now, we will use some placeholders for both. Also the banner will display the user's biography, tweet, following and follower counts. In addition, we want to display a follow/unfollow button for each user profile other than the user's own profile."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"img","props":{"alt":"Profile","src":"/img/page3/profile.png"},"children":[]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Moreover we will use the "},{"type":"element","tag":"a","props":{"href":"https://api.flutter.dev/flutter/material/BottomNavigationBar-class.html","rel":["nofollow"]},"children":[{"type":"text","value":"BottomNavigationBar"}]},{"type":"text","value":" widget to show the user's tweets and replies on different pages. Just as we provide a RefreshIndicator widget to refresh the timeline, we will also provide a RefreshIndicator widget to refresh the profile page. With this feature, we can update tweet stats and new tweets."}]},{"type":"element","tag":"h4","props":{"id":"explore"},"children":[{"type":"text","value":"Explore"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The Explore page will show the top 10 trending topics and their statistics. The Listview widget is also used for this purpose. When we look at how we will get hashtags from tweet, we will add "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"mentions"}]},{"type":"text","value":" and "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"hashtags"}]},{"type":"text","value":" fields to each tweet document. Then we will define a scheduled task in Firebase to look up tweets that were posted last hour. This task will generate list of top 10 hashtags that were use."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The trending topics will be listed like tweets in the timeline when the user chooses to view them. We will fetch 20 tweets at a time and display them in ascending order of their creation time."}]},{"type":"element","tag":"h4","props":{"id":"messages"},"children":[{"type":"text","value":"Messages"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The messages screen will host a basic real-time messaging application. We will host chats in the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"chats"}]},{"type":"text","value":" document in the Firestore and fetch chat and it's messages from there. For ease of implementation we won't let the user delete messages. Again for ease of implementation we only accept text messages."}]},{"type":"element","tag":"h4","props":{"id":"other-screens"},"children":[{"type":"text","value":"Other Screens"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"We also have notifications and search results, in addition to all of these. With Firestore we could store all notifications, but I prefer to store the last 10 for ease of implementation. Firestore does not support full-text searching, so we have to rely on a third-party solution for our searches. In the official documentation, a few products are suggested for search. In light of this, I chose to stick with "},{"type":"element","tag":"a","props":{"href":"https://www.algolia.com/","rel":["nofollow"]},"children":[{"type":"text","value":"Algolia"}]},{"type":"text","value":" because it has Dart library and Firebase extension and it's free."}]},{"type":"element","tag":"h3","props":{"id":"practice"},"children":[{"type":"text","value":"Practice"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"With a broad plan in our hands, and an idea of how we will accomplish our goal, we need to solve an issue; how are we planning to communicate between our screens, in other words how are we planning to manage state? When it comes to state management, Flutter and Dart have lots of packages. The most known and used package is called "},{"type":"element","tag":"a","props":{"href":"https://pub.dev/packages/provider","rel":["nofollow"]},"children":[{"type":"text","value":"Provider"}]},{"type":"text","value":". In the first part, I mentioned a third type of widget called an "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"inherited widget"}]},{"type":"text","value":". Provider package wraps inherited widgets and provide us a useful API. So you might wonder, what is an inherited widget? An inherited widget does not have a display. Whenever you place an inherited widget into the widget tree, every child widget and every child of that child can reach directly to it. This is because there is no need for an intermediary widget. The provider package uses this feature to manipulate data. Any child can access this data and modify it easily. If you use a provider, you need to use the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"ChangeNotifier"}]},{"type":"text","value":" mixin to have the "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"notifyListeners"}]},{"type":"text","value":" function. This function does the same job that "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"setState"}]},{"type":"text","value":" function does. It notifies Flutter that some data in the application state has changed, so it needs to rebuild the widgets."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"While there are other options like Redux, BloC, and GetIt, I decided to stick with the "},{"type":"element","tag":"a","props":{"href":"https://riverpod.dev/","rel":["nofollow"]},"children":[{"type":"text","value":"RiverPod"}]},{"type":"text","value":" package because I find it easier to use. Also it uses similar API like provider package but it has far more features than that. Other than a basic provider, it has StateProvider for changing states, FutureProvider for asynchronous data and StreamProvider for realtime data."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"So how are we aiming to use state management in our application? In order to avoid re-fetching tweets, we have to store them in the cache when we retrieve them. Retrieving the data repeatedly wastes our time and delays the user. Apart from tweets, we need to store the user's information. This is because most of the time we need the user's data, for example when fetching tweets we need the user's followings. We don't want to fetch this information repeatedly. It will save the user a great deal of bandwidth and time in real-world applications."}]},{"type":"element","tag":"h4","props":{"id":"environment"},"children":[{"type":"text","value":"Environment"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"I discuss a lot about Dart and Flutter, but do not mention anything about development environments. As a last thing, let's talk about it. For application development with Flutter, you need to have the SDK. The SDK can be downloaded from the "},{"type":"element","tag":"a","props":{"href":"https://docs.flutter.dev/get-started/install","rel":["nofollow"]},"children":[{"type":"text","value":"official website"}]},{"type":"text","value":". It supports most major operating systems. It also includes the Dart SDK, so you don't need to install both. After SDK installation, go to the command line or console and type "},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"flutter doctor"}]},{"type":"text","value":". This command shows what dependencies are missing and what you should do. Other than that you must have Android SDKs, so I strongly suggest you to install Android Studio for that. Because you can select which SDKs to download and it has a built-in emulator with it. For programming you don't have to stick with Android Studio though, you can work with Visual Studio Code. All you need to install is the Flutter extension and you are ready to start."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"second-step-plan-and-practice","depth":2,"text":"Second Step: Plan and Practice","children":[{"id":"the-plan","depth":3,"text":"The Plan"},{"id":"practice","depth":3,"text":"Practice"}]}]}},"_type":"markdown","_id":"content:page3.md","_source":"content","_file":"page3.md","_extension":"md"}